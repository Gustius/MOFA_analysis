---
title: " Vignette illustrating the use of MOFA on the scMT data"
author: "Ricard Argelaguet and Britta Velten"
date: "`r Sys.Date()`"
output:
  BiocStyle::html_document:
    toc: true
vignette: >
  %\VignetteIndexEntry{Example_scMT}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo=FALSE, message=FALSE}
devtools::load_all("/Users/ricard/mofa/MOFAtools")
library(MultiAssayExperiment)
library(MOFAtools)
library(data.table)
library(purrr)
```

# Step 1: Initialize MOFA model

## Load data as a MultiAssayExperiment
```{r}
sample_metadata <- read.table("/Users/ricard/data/scMT/sample_info.txt", header=T) %>% tibble::column_to_rownames("sample")
mae <- readRDS("/Users/ricard/data/scMT/join/scMT_MultiAssayExperiment.rds")
```

## Create MOFA model
```{r}
model <- createMOFAobject(mae)
```

# Step 2: Fit the MOFA model

## Define options

### Define I/O options
```{r}
DirOptions <- list(
  # "tmpDir" = tempdir(),
  "tmpDir" = "/tmp/test",
  "mofaDir" = "/Users/ricard/mofa/MOFA",
  "outFile" = "/Users/ricard/scMT/mofa/out/model.hdf5"
)
```

### Define model options
```{r}
ModelOptions <- getDefaultModelOpts(model)
ModelOptions$initialK <- 30
ModelOptions$learnMean <- F

# Define covariates
ModelOptions$covariates <- colData(mae)[,c("cell_dropout"), drop=F]
stopifnot(all(rownames(ModelOptions$covariates)==sampleNames(model)))
ModelOptions$scale_covariates <- rep(1,ncol(ModelOptions$covariates))
```


### Define training options
```{r}
TrainOptions <- getDefaultTrainOpts()
TrainOptions$maxiter <- 2000
TrainOptions$startSparsity <- 200
TrainOptions$drop_by_norm <- 0.00
TrainOptions$drop_by_r2 <- 0.05
```

## Prepare MOFA
Internally, prepareMOFA performs a set of sanity checks, fills the TrainOpts and ModelOpts slots of the MOFAmodel model and it also creates a set of temporary files with the input matrices that will be loaded by the Python core implementation
```{r}
model <- prepareMOFA(model, 
                      DirOptions = DirOptions,
                      ModelOptions = ModelOptions,
                      TrainOptions = TrainOptions
)
```



## Run MOFA
This step can take some time and it decouples from the R package, it is recommended to run it from the Python-based module
```{r}

# Training the model from R
# model <- runMOFA(model, DirOptions)

# Training the model from Python
model <- loadModel("/Users/ricard/scMT/mofa/out/model_test.hdf5", sortFactors = F)
model@InputData <- mae

```






# Step 3: Analyse a trained MOFA model

## Show the variance explained for each factor in each view
```{r, fig.height=7, fig.width=7}
r2 <- calculateVarianceExplained(model, views="all", factors="all", plotit=T, perFeature=F, 
                           orderFactorsbyR2=F, showtotalR2=F)
```


## Scatterplots of pairs of latent variables
```{r}

Z <- getExpectations(model,"Z","E")

e <- model@TrainData$expr
m <- model@TrainData$met_prom_cgi

# culture <- sample_metadata[sampleNames(model),]$culture
scatterPairs(model, factors = c("1","7"), color_by="mean_methylation", shape_by="culture", colorLegend=T, shapeLegend = T)

clusters <- rep(NA,length(sampleNames(model))); names(clusters) <- sampleNames(model)
clusters[names(which(Z[,"5"]<0.3 & Z[,"4"]>(-0.5)))] <- "1"
clusters[names(which(Z[,"5"]>0.3 & Z[,"4"]>(-0.5)))] <- "2"
clusters[names(which(Z[,"4"]<(-0.5)))] <- "3"
# clusters <- cut(Z[,"5"], breaks=c(-Inf,0,Inf), labels=c("1","2"))

colData(model@InputData)$cluster <- clusters
scatterPlot(model, factors=c("1","4"))
# scatterPlot(model, factors=c("1","7"), colour_by="culture", shape_by="culture")

histPlot(model, factor="6")
```

### Correlation of latent variables
```{r}
FactorsCorPlot(model)

r <- CorrplotLFvsPC(model, views = "all", noPCs = 3, method = "bpca")
```



## Characterisation of specific latent factors

### Correlation with covariates
```{r}
# Mean methylation rate
beeswarmPlot(model, factors="1", color_by = "mean_methylation", color_name="", colorLegend=T)

# cor( colMeans(model@TrainData$met_genebody, na.rm=T), getExpectations(model,"Z","E"), use="complete.obs")
```

### Plot sparsity
```{r}

```

### Show weights and identify most relevant features
```{r}

pluri <- fread("/Users/ricard/NMT-seq/genesets/pluripotency.tsv", header=F) %>% setnames(c("ens_id","gene")) %>% .[["gene"]]
pluri <- pluri[pluri %in% featureNames(model)[["expr"]]]
showWeightHeatmap(model, "expr", factors = c("4","2","7","5"), show_rownames=F)
showAllWeights(model, view="expr", factor="10")
<# showAllWeights(model, view="expr", factor="7", nfeatures=0, abs =FALSE, manual=list(pluri), main="")
showAllWeights(model, view="expr", factor="4", nfeatures=10, abs=FALSE, main="")
showTopWeights(model, view="expr", factor="2", nfeatures=10,  manual_features=NULL, sign="negative", abs=FALSE)
showTopWeights(model, view="expr", factor="2", nfeatures=10,  manual_features=NULL, sign="positive", abs=FALSE)

```

### Show original data for the genes with top weights
```{r, fig.height=4, fig.width=7}

# Latent variable 4 (methylation factor)
# row_df <- data.frame(
#   row.names=sampleNames(model),
#   # culture=model@InputData$culture
#   # culture=sample_metadata$culture
#   # cluster=model@InputData$cluster
# )
# col_df <- data.frame(
#   row.names=featureNames(model)[["expr"]],
#   pluri=featureNames(model)[["expr"]]%in% pluri
#   # cluster=model@InputData$cluster
# )
showDataHeatmap(model, view="met_genebody", factor="1", nfeatures=500, show_colnames=F, show_rownames=F, annotation_row=row_df)

showDataHeatmap(model, view="met_prom_cgi", factor="10", nfeatures=50, show_colnames=F, show_rownames=T, fontsize_row=8)
showDataHeatmap(model, view="expr", factor="4", nfeatures=500, show_colnames=F, show_rownames=F, fontsize_row=8)

# Latent variable 2 (shared expression and methylation factor)

# Latent variable 5 (expression pluripotency component)
# showDataScatter(model, view, factor, nfeatures=50, colour_by=NULL, shape_by=NULL)
```


## Feature set enrichment analysis
The characterisation of factors usually requires the inspection of the corresponding weights to identify features with strong influence. However, looking at single features can be challenging and often the combination of signal from functionally related sets of features (i.e. gene ontologies) is required.
Here we implemented a feature set enrichment analysis method (FeatureSetEnrichmentAnalysis) derived from the PCGSE package (REF).
The input of these function is a MOFA trained model (MOFAmodel), the factors for which to perform feature set enrichment (character vector), the feature sets (matrix) and a set of options regarding how the analysis should be performed. For more information see ...

### Calculate enrichment scores
Here we are going to perform feature set enrichment analysis on the mRNA view.
Here we are going to use the absolute value of the weight (or loading) as feature statistic, the mean difference between the features in the gene set and the features outside the gene set as a feature set statistic and the correlation-adjusted parametric statistical test.
```{r}
# The input format for feature sets has to be a binary matrix where the rows represent feature sets and the columns are features where a value of 1 indicates that the feature belongs to the corresponding feature set.

# Load reactome annotations
# feature.sets <- 
feature.sets <- rbind(
  readRDS("/Users/ricard/data/reactome/v59/mus_musculus/out/mouse_v75_reactome.rds"),
  # readRDS("/Users/ricard/data/MSigDB/v6.0/mus_musculus/C5/bp_binary_matrix_ensembl.rds"),
  readRDS("/Users/ricard/data/manual_genesets/binary_matrix.rds")
)

# Run Feature Set Enrichment Analysis
fsea.out <- FeatureSetEnrichmentAnalysis(
  model,
  view = "expr", 
  factors = "all", 
  feature.sets = feature.sets,
  local.statistic = "loading",
  transformation = "abs.value",
  global.statistic = "mean.diff",
  statistical.test = "cor.adj.parametric",
  nperm=NA, 
  min.size=10,
  cores=1
)

# Extract p values
pval <- fsea.out$pval.adj

# Rename pathways
tmp <- read.table("/Users/ricard/data/reactome/v59/mus_musculus/AllPathways.txt", header=F, quote="", sep="\t", stringsAsFactors=F)[,c(1,2)]
reactome_meta <- tmp[,2]; names(reactome_meta) <- tmp[,1]
rownames(pval) <- stringr::str_replace_all(rownames(pval), reactome_meta)
```

### Visualise the results
```{r}
# all factors
Heatmap_FeatureSetEnrichmentAnalysis(pval, threshold=0.001, main="Overview of gene ontology enrichment analysis", 
                                     cluster_rows = F, cluster_cols = F, show_rownames = F, show_colnames = T)

# individual factors
LinePlot_FeatureSetEnrichmentAnalysis(pval, view="expr", factor="9", threshold=0.1, max.pathways=25)
```


<!-- # Cluster samples -->
<!-- ```{r} -->
<!-- clusterMOFA(model, factors) -->
<!-- ``` -->

# Imputation
```{r}
Ypred <- imputeMissing(model, viewnms = "Expression")@ImputedData$Expression
```


# Sharedness of methylation and expression
```{r}

# Get top featuresof super enhancers in latent variable 1 (mean methylation rate)
foo <- names(tail(sort(getExpectations(model,"SW","E")[["met_super_enhancers"]][,"7"]),n=25))
bar <- names(head(sort(getExpectations(model,"SW","E")[["met_super_enhancers"]][,"7"]),n=25))

# Get top features of super enhancers in latent variable 7 (pluripotency)
baz <- names(getExpectations(model,"SW","E")[["met_super_enhancers"]][,"1"])
# baz <- baz[!baz %in% c(foo,bar)]


# Load methylation data
tmp <- data.table(sample=sampleNames(model), pluri=getExpectations(model,"Z","E")[,"7"])
# met <- fread("zcat < /Users/ricard/data/scMT/met/parsed/all.tsv.gz") %>% .[anno %in% "super_enhancers"] %>% merge(tmp)
met_foo <- met[id %in% foo] %>% .[,group:="1"]
met_baz <- met[id %in% baz] %>% .[,group:="2"]
met_bar <- met[id %in% bar] %>% .[,group:="3"]
small_met <- rbind(met_bar,met_foo,met_baz)

to.plot <- small_met[,.(r=cor(rate,pluri, method="spearman")), by=c("id","anno","group")]
ggplot(to.plot, aes(x=group, y=r, fill=group)) +
  geom_boxplot(outlier.shape = NA) +
  scale_y_continuous(limits = c(0.5,0.9)) +
  theme_bw()

```


